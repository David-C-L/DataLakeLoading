#pragma once

#include "DadsConnectorSplit.h"
#include "velox/connectors/Connector.h"
#include "velox/exec/tests/utils/PlanBuilder.h"

using namespace facebook::velox;
using namespace facebook::velox::connector;
using namespace facebook::velox::memory;
using namespace facebook::velox::exec::test;

namespace dads::engines::velox {

// TPC-H column handle only needs the column name (all columns are generated in
// the same way).
class DadsColumnHandle : public ColumnHandle {
public:
  explicit DadsColumnHandle(std::string const& name) : name_(name) {}

  std::string const& name() const { return name_; }

private:
  std::string const name_;
};

// TPC-H table handle uses the underlying enum to describe the target table.
class DadsTableHandle : public ConnectorTableHandle {
public:
  explicit DadsTableHandle(std::string const& connectorId, std::string&& tableName,
                           RowTypePtr&& dadsTableSchema, std::vector<RowVectorPtr>&& rowDataVec,
                           std::vector<size_t>&& dadsSpanRowCountVec)
      : ConnectorTableHandle(connectorId), tableName_(std::move(tableName)),
        tableSchema_(std::move(dadsTableSchema)), rowDataVec_(std::move(rowDataVec)),
        spanRowCountVec_(std::move(dadsSpanRowCountVec)) {}

  ~DadsTableHandle() override {}

  std::string toString() const override;

  std::string const& getTable() const& { return tableName_; }

  RowTypePtr getTableSchema() const& { return tableSchema_; }

  std::vector<RowVectorPtr> const& getRowDataVec() const { return rowDataVec_; }

  std::vector<size_t> const& getSpanRowCountVec() const { return spanRowCountVec_; }

private:
  std::string tableName_;
  RowTypePtr tableSchema_;
  std::vector<RowVectorPtr> rowDataVec_;
  std::vector<size_t> spanRowCountVec_;
};

class DadsDataSource : public DataSource {
public:
  DadsDataSource(std::shared_ptr<RowType const> const& outputType,
                 std::shared_ptr<connector::ConnectorTableHandle> const& tableHandle,
                 std::unordered_map<std::string, std::shared_ptr<connector::ColumnHandle>> const&
                     columnHandles,
                 memory::MemoryPool* FOLLY_NONNULL pool);

  void addSplit(std::shared_ptr<ConnectorSplit> split) override;

  void addDynamicFilter(column_index_t /*outputChannel*/,
                        std::shared_ptr<common::Filter> const& /*filter*/) override {
    VELOX_NYI("Dynamic filters not supported by DadsConnector.");
  }

  std::optional<RowVectorPtr> next(uint64_t size, ContinueFuture& future) override;

  uint64_t getCompletedRows() override { return completedRows_; }

  uint64_t getCompletedBytes() override { return completedBytes_; }

  std::unordered_map<std::string, RuntimeCounter> runtimeStats() override {
    // TODO: Which stats do we want to expose here?
    return {};
  }

private:
  RowVectorPtr getDadsData(uint64_t length);

  RowTypePtr const& outputType_;
  std::shared_ptr<DadsTableHandle> dadsTableHandle_;
  std::string const& dadsTableName_;
  std::vector<RowVectorPtr> const& dadsRowDataVec_;
  std::vector<size_t> const& dadsSpanRowCountVec_;

  // Mapping between output columns and their indices (column_index_t) in the datasets.
  std::vector<column_index_t> outputColumnMappings_;

  std::shared_ptr<DadsConnectorSplit> currentSplit_;

  // First (splitOffset_) and last (splitEnd_) row number that should be
  // generated by this split.
  uint64_t splitOffset_{0};
  uint64_t splitEnd_{0};
  size_t spanCountIdx_{0};

  size_t completedRows_{0};
  size_t completedBytes_{0};

  memory::MemoryPool* FOLLY_NONNULL pool_;
};

class DadsConnector final : public Connector {
public:
  DadsConnector(std::string const& id, std::shared_ptr<const Config> properties,
                folly::Executor* FOLLY_NULLABLE /*executor*/)
      : Connector(id) {}

  std::unique_ptr<DataSource>
  createDataSource(std::shared_ptr<const RowType> const& outputType,
                   std::shared_ptr<connector::ConnectorTableHandle> const& tableHandle,
                   std::unordered_map<std::string, std::shared_ptr<connector::ColumnHandle>> const&
                       columnHandles,
                   ConnectorQueryCtx* FOLLY_NONNULL connectorQueryCtx) override final {
    return std::make_unique<DadsDataSource>(outputType, tableHandle, columnHandles,
                                            connectorQueryCtx->memoryPool());
  }

  std::unique_ptr<DataSink>
  createDataSink(RowTypePtr /*inputType*/,
                 std::shared_ptr<ConnectorInsertTableHandle> /*connectorInsertTableHandle*/,
                 ConnectorQueryCtx* /*connectorQueryCtx*/,
                 CommitStrategy /*commitStrategy*/) override final {
    VELOX_NYI("DadsConnector does not support data sink.");
  }
};

class DadsConnectorFactory : public ConnectorFactory {
public:
  static constexpr char const* FOLLY_NONNULL kDadsConnectorName{"dads"};

  DadsConnectorFactory() : ConnectorFactory(kDadsConnectorName) {}

  explicit DadsConnectorFactory(char const* FOLLY_NONNULL connectorName)
      : ConnectorFactory(connectorName) {}

  std::shared_ptr<Connector>
  newConnector(std::string const& id, std::shared_ptr<Config const> properties,
               folly::Executor* FOLLY_NULLABLE executor = nullptr) override {
    return std::make_shared<DadsConnector>(id, properties, executor);
  }
};

} // namespace dads::engines::velox
